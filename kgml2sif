#!/usr/bin/env python3
#### LICENSE ###################################################################
# Copyright (C) 2019 Arnaud Poret
# This work is licensed under the GNU General Public License.
# To view a copy of this license, visit https://www.gnu.org/licenses/gpl.html
#### IMPORTS ###################################################################
import argparse
import copy
import os.path
import xml.etree.ElementTree
#### PARSER ####################################################################
parser=argparse.ArgumentParser(
description="""
Convert KGML-encoded KEGG human pathways to the SIF file format.
""",
epilog="""
Currently:
    * the following node types are considered:
        * gene
        * compound
        * group (in KGML, groups are complexes)
    * the following relation types are considered (in KGML, relations are
      edges):
        * PPrel (protein-protein)
        * GErel (gene expression)
        * PCrel (protein-compound)
        * ECrel (enzyme-compound)

In the output SIF file:
    * relation names (i.e. edge names) are suffixed with their corresponding
      type, ex:
        * phosphorylation_PPrel
        * repression_GErel
    * if necessary, edges having multiple types are split in order to obtain one
      type per edge (warning: it can create multi-edges)
    * multi-edges, if any, are left inside the output SIF file and kgml2sif
      warns about it
    * the non-KGML "membership_CPXrel" relation is added to indicate when a node
      is component of a complex (CPXrel stands for relations involving
      complexes, an added non-KGML relation type)
    * complexes are named as follows: cp1::cp2::cp3, where cp1, cp2 and cp3 are
      the complex components
    * by the way, in this example of a 3-components complex, the following edges
      would be added as explain above:
        * cp1    membership_CPXrel    cp1::cp2::cp3
        * cp2    membership_CPXrel    cp1::cp2::cp3
        * cp3    membership_CPXrel    cp1::cp2::cp3

If -s/--symbol or -c/--compound is used:
    * the conversion table must be a 2-columns TSV file
    * unmatched KEGG IDs are left unchanged in the output SIF file and kgml2sif
      warns about it

Node name prefixes in KGML:
    * specify the node type
    * the name of nodes representing human genes is prefixed with "hsa:"
    * the name of nodes representing compounds is prefixed with "cpd:"
    * the name of nodes representing glycans (a subtype of compounds) is
      prefixed with "gl:"
    * the name of nodes representing drugs (a subtype of compounds) is prefixed
      with "dr:"

Full explanation of the KGML file format at https://www.kegg.jp/kegg/xml/docs/

For explanations about the SIF file format, see the readme file of kgml2sif.
""",
formatter_class=argparse.RawDescriptionHelpFormatter
)
parser.add_argument(
    "kgmlfile",
    type=str,
    metavar="<kgmlfile>",
    help="a KGML-encoded KEGG human pathway",
    nargs="+"
)
parser.add_argument(
    "-s",
    "--symbol",
    type=str,
    metavar="<tsvfile>",
    help="a conversion table for translating KEGG human gene IDs to gene symbols (see the file \"gene2symbol.tsv\" provided with kgml2sif)"
)
parser.add_argument(
    "-c",
    "--compound",
    type=str,
    metavar="<tsvfile>",
    help="a conversion table for translating KEGG compound IDs to compound names (see the file \"compound2name.tsv\" provided with kgml2sif)"
)
parser.add_argument(
    "-p",
    "--prefix",
    action="store_true",
    help="keep node name prefixes if -s/--symbol or -c/--compound is used"
)
args=parser.parse_args()
#### GLOBALS ###################################################################
gene2symbol={}
compound2name={}
nodeTypes=["gene","compound","group"]
relTypes=["PPrel","GErel","PCrel","ECrel"]
relTypeAdds=["CPXrel"]
genePrefixes=["hsa"]
compoundPrefixes=["cpd","gl","dr"]
#### KEGG2SYMBOL ###############################################################
if args.symbol!=None:
    warnFile=list(os.path.splitext(args.symbol))
    warnFile[1]=".warns.txt"
    warnFile="".join(warnFile)
    warns=[]
    for line in open(args.symbol,"rt").read().splitlines():
        if line.count("\t")!=1:
            warns.append(line+": must be a 2-columns TSV, skipping")
        else:
            line=line.split("\t")
            ok=True
            for val in line:
                if val.strip()=="":
                    warns.append("\t".join(line)+": empty field(s), skipping")
                    ok=False
                    break
            if ok:
                if not (line[0].startswith("hsa:") and line[0].replace("hsa:","").isnumeric()):
                    warns.append("\t".join(line)+": invalid KEGG human gene ID, skipping")
                elif line[0] in gene2symbol.keys():
                    warns.append("\t".join(line)+": duplicated KEGG human gene ID, skipping")
                else:
                    gene2symbol[line[0]]=line[1]
    if len(warns)!=0:
        print("Warning: "+args.symbol+": see "+warnFile)
        open(warnFile,"w").write("\n".join(warns)+"\n")
    if len(gene2symbol.keys())==0:
        print("Error: "+args.symbol+": empty after reading")
        quit()
#### COMPOUND2NAME #############################################################
if args.compound!=None:
    warnFile=list(os.path.splitext(args.compound))
    warnFile[1]=".warns.txt"
    warnFile="".join(warnFile)
    warns=[]
    for line in open(args.compound,"rt").read().splitlines():
        if line.count("\t")!=1:
            warns.append(line+": must be a 2-columns TSV, skipping")
        else:
            line=line.split("\t")
            ok=True
            for val in line:
                if val.strip()=="":
                    warns.append("\t".join(line)+": empty field(s), skipping")
                    ok=False
                    break
            if ok:
                if not ((line[0].startswith("cpd:C") or line[0].startswith("gl:G") or line[0].startswith("dr:D")) and line[0].replace("cpd:C","").replace("gl:G","").replace("dr:D","").lstrip("0").isnumeric()):
                    warns.append("\t".join(line)+": invalid KEGG compound ID, skipping")
                elif line[0] in compound2name.keys():
                    warns.append("\t".join(line)+": duplicated KEGG compound ID, skipping")
                else:
                    compound2name[line[0]]=line[1]
    if len(warns)!=0:
        print("Warning: "+args.compound+": see "+warnFile)
        open(warnFile,"w").write("\n".join(warns)+"\n")
    if len(compound2name.keys())==0:
        print("Error: "+args.compound+": empty after reading")
        quit()
#### KGML FILES ################################################################
for kgmlFile in args.kgmlfile:
    #### OUT FILES #############################################################
    warnFile=list(os.path.splitext(kgmlFile))
    notFoundFile=list(os.path.splitext(kgmlFile))
    multiFile=list(os.path.splitext(kgmlFile))
    sifFile=list(os.path.splitext(kgmlFile))
    warnFile[1]=".warns.txt"
    notFoundFile[1]=".notfound.txt"
    multiFile[1]=".multi.sif"
    sifFile[1]=".sif"
    warnFile="".join(warnFile)
    notFoundFile="".join(notFoundFile)
    multiFile="".join(multiFile)
    sifFile="".join(sifFile)
    #### INIT ##################################################################
    warns=[]
    notFound=[]
    nodes={}
    complexes={}
    edges={}
    sif=[]
    multiEdges=[]
    root=xml.etree.ElementTree.parse(kgmlFile).getroot()
    #### NODES #################################################################
    for element in root.findall("entry"):
        nodeType=element.get("type")
        ID=element.get("id")
        names=element.get("name")
        if nodeType not in nodeTypes:
            warns.append(nodeType+": unconsidered node type, skipping")
        elif (ID==None) or (ID.strip()==""):
            warns.append(nodeType+": no ID, skipping")
        elif (ID in nodes.keys()) or (ID in complexes.keys()):
            warns.append(nodeType+": "+ID+": duplicated node ID, skipping")
        elif (names==None) or (names.strip()==""):
            warns.append(nodeType+": "+ID+": no name(s), skipping")
        else:
            if nodeType=="group":
                complexes[ID]=copy.deepcopy(element)
            else:
                nodes[ID]=[]
                for name in names.split(" "):
                    if name not in nodes[ID]:
                        nodes[ID].append(name)
    if len(nodes.keys())==0:
        if len(warns)!=0:
            print("Warning: "+kgmlFile+": see "+warnFile)
            open(warnFile,"w").write("\n".join(warns)+"\n")
        print("Error: "+kgmlFile+": no nodes found, skipping")
        continue
    #### NAME NODES ############################################################
    if args.symbol!=None:
        for ID in nodes.keys():
            for i in range(len(nodes[ID])):
                prefix=nodes[ID][i].split(":")[0]
                if prefix in genePrefixes:
                    if nodes[ID][i] in gene2symbol.keys():
                        if args.prefix:
                            nodes[ID][i]=":".join([prefix,gene2symbol[nodes[ID][i]]])
                        else:
                            nodes[ID][i]=gene2symbol[nodes[ID][i]]
                    elif nodes[ID][i] not in notFound:
                        notFound.append(nodes[ID][i])
    if args.compound!=None:
        for ID in nodes.keys():
            for i in range(len(nodes[ID])):
                prefix=nodes[ID][i].split(":")[0]
                if prefix in compoundPrefixes:
                    if nodes[ID][i] in compound2name.keys():
                        if args.prefix:
                            nodes[ID][i]=":".join([prefix,compound2name[nodes[ID][i]]])
                        else:
                            nodes[ID][i]=compound2name[nodes[ID][i]]
                    elif nodes[ID][i] not in notFound:
                        notFound.append(nodes[ID][i])
    #### DEDUPLICATE NODE NAMES ################################################
    for ID in nodes.keys():
        noDups=[]
        for name in nodes[ID]:
            if name not in noDups:
                noDups.append(name)
        nodes[ID]=copy.deepcopy(noDups)
    #### COMPLEXES #############################################################
    for ID in complexes.keys():
        components=complexes[ID].findall("component")
        if len(components)==0:
            warns.append(ID+": complex with no components, skipping")
        elif len(components)==1:
            warns.append(ID+": complex with only one component, skipping")
        else:
            componentIDs=[]
            ok=True
            for component in components:
                componentID=component.get("id")
                if (componentID==None) or (componentID.strip()==""):
                    warns.append(ID+": complex with component with no ID, skipping")
                    ok=False
                    break
                elif componentID not in nodes.keys():
                    warns.append(ID+": complex with unconsidered or unknown component, skipping")
                    ok=False
                    break
                elif componentID not in componentIDs:
                    componentIDs.append(componentID)
            if ok:
                if len(componentIDs)==0:
                    warns.append(ID+": complex with no valid components, skipping")
                else:
                    members=[]
                    cpxs1=[]
                    cpxs2=[]
                    nodes[ID]=[]
                    for componentID in componentIDs:
                        members.append(copy.deepcopy(nodes[componentID]))
                    n=len(members)
                    m=1
                    for i in range(n):
                        m*=len(members[i])
                    for i in range(n):
                        cpxs1.append([])
                        p=len(members[i])
                        q=1
                        for j in range(i+1,n):
                            q*=len(members[j])
                        for j in range(m):
                            cpxs1[i].append(members[i][(j//q)%p])
                    for i in range(m):
                        cpxs2.append([])
                        for j in range(n):
                            cpxs2[i].append(cpxs1[j][i])
                        cpxs2[i]=sorted(cpxs2[i])
                    for cpx in sorted(cpxs2):
                        name="::".join(cpx)
                        if name not in nodes[ID]:
                            nodes[ID].append(name)
                        for node in cpx:
                            sif.append([node,["membership_CPXrel"],name])
    #### RELATIONS #############################################################
    for relation in root.findall("relation"):
        relType=relation.get("type")
        entry1=relation.get("entry1")
        entry2=relation.get("entry2")
        subtypes=relation.findall("subtype")
        if relType not in relTypes:
            warns.append(relType+": unconsidered relation type, skipping")
        elif (entry1==None) or (entry1.strip()==""):
            warns.append(relType+": no source node, skipping")
        elif (entry2==None) or (entry2.strip()==""):
            warns.append(relType+": no target node, skipping")
        elif entry1 not in nodes.keys():
            warns.append(relType+": ("+entry1+","+entry2+"): unconsidered or unknown source node, skipping")
        elif entry2 not in nodes.keys():
            warns.append(relType+": ("+entry1+","+entry2+"): unconsidered or unknown target node, skipping")
        elif len(subtypes)==0:
            warns.append(relType+": ("+entry1+","+entry2+"): no name(s), skipping")
        else:
            names=[]
            ok=True
            for subtype in subtypes:
                name=subtype.get("name")
                if (name==None) or (name.strip()==""):
                    warns.append(relType+": ("+entry1+","+entry2+"): missing name, skipping")
                    ok=False
                    break
                elif name not in names:
                    names.append(name)
            if ok:
                if len(names)==0:
                    warns.append(relType+": ("+entry1+","+entry2+"): no valid name(s), skipping")
                else:
                    for i in range(len(names)):
                        names[i]="_".join([names[i],relType])
                    for source in nodes[entry1]:
                        for target in nodes[entry2]:
                            sif.append([source,copy.deepcopy(names),target])
    if len(sif)==0:
        if len(warns)!=0:
            print("Warning: "+kgmlFile+": see "+warnFile)
            open(warnFile,"w").write("\n".join(warns)+"\n")
        print("Error: "+kgmlFile+": no edges found, skipping")
        continue
    #### CLEAN EDGES ###########################################################
    for edge in sif:
        edges[edge[0]]={}
    for edge in sif:
        edges[edge[0]][edge[2]]={}
    for source in edges.keys():
        for target in edges[source].keys():
            for relType in relTypes+relTypeAdds:
                edges[source][target][relType]=[]
    for edge in sif:
        for relation in edge[1]:
            for relType in relTypes+relTypeAdds:
                if relation.endswith(relType):
                    if relation not in edges[edge[0]][edge[2]][relType]:
                        edges[edge[0]][edge[2]][relType].append(relation)
                    break
    sif=[]
    for source in edges.keys():
        for target in edges[source].keys():
            multi=0
            for relType in edges[source][target].keys():
                if len(edges[source][target][relType])!=0:
                    multi+=1
            for relType in edges[source][target].keys():
                if len(edges[source][target][relType])!=0:
                    edge="\t".join([source,",".join(edges[source][target][relType]),target])
                    if edge not in sif:
                        sif.append(edge)
                    if (multi>1) and (edge not in multiEdges):
                        multiEdges.append(edge)
    #### OUTPUTS ###############################################################
    if len(warns)!=0:
        print("Warning: "+kgmlFile+": see "+warnFile)
        open(warnFile,"w").write("\n".join(warns)+"\n")
    if len(notFound)!=0:
        print("Warning: "+kgmlFile+": contains unmatched KEGG IDs, see "+notFoundFile)
        open(notFoundFile,"w").write("\n".join(sorted(notFound))+"\n")
    if len(multiEdges)!=0:
        print("Warning: "+kgmlFile+": contains multi-edges, see "+multiFile)
        open(multiFile,"w").write("\n".join(sorted(multiEdges))+"\n")
    open(sifFile,"w").write("\n".join(sorted(sif))+"\n")
