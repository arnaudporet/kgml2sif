#!/usr/bin/env python3
#### LICENSE ###################################################################
# Copyright (C) 2019 Arnaud Poret
# This work is licensed under the GNU General Public License.
# To view a copy of this license, visit https://www.gnu.org/licenses/gpl.html
#### IMPORTS ###################################################################
import argparse
import copy
import os.path
import xml.etree.ElementTree
#### PARSER ####################################################################
parser=argparse.ArgumentParser(
description="""
Convert KGML-encoded KEGG human pathways to the SIF file format.
""",
epilog="""
Currently:
    * the following node types are considered:
        * gene (in KGML, genes also hold for the corresponding proteins/gene
          products)
        * compound
        * group (in KGML, groups hold for complexes)
    * the following relation types are considered (in KGML, relations hold for
      edges):
        * PPrel: protein-protein, protein-complex or complex-complex links
        * GErel: protein-gene or complex-gene links (i.e. gene expression)
        * PCrel: protein-compound or complex-compound links
        * ECrel: enzyme-enzyme links sharing a common compound (as product for
          the first enzyme and as substrate for the second one)

In the output SIF file:
    * edge names (i.e. relation names) are suffixed with their corresponding
      type, ex:
        * phosphorylation_PPrel
        * repression_GErel
    * edges for which the name is missing are automatically named "unknown",
      suffixed with their corresponding type, ex:
        * unknown_PCrel
    * edges are automatically checked regarding their type and the nodes they
      link:
        * PPrel:
            (source=protein OR source=complex) AND (target=protein OR target=complex)
        * GErel:
            (source=protein OR source=complex) AND (target=gene)
        * PCrel:
            (source=protein OR source=complex) AND (target=compound)
            OR
            (source=compound) AND (target=protein OR target=complex)
        * ECrel:
            (source=protein OR source=complex) AND (target=protein OR target=complex)
    * if necessary, edges having multiple types are split in order to obtain one
      type per edge (warning: it can create multi-edges)
    * multi-edges, if any, are left inside the output SIF file and kgml2sif
      warns about it
    * the non-KGML "membership_CPXrel" edges are added in order to indicate when
      nodes are component of complexes (CPXrel is an added non-KGML relation
      type)
    * complexes are named as follows:
        * cp1&cp2&cp3
        * where cp1, cp2 and cp3 are the complex components
    * by the way, in this example of a 3-components complex, the following edges
      would be added as explain above:
        * cp1    membership_CPXrel    cp1&cp2&cp3
        * cp2    membership_CPXrel    cp1&cp2&cp3
        * cp3    membership_CPXrel    cp1&cp2&cp3

If -g/--geneSymbol or -c/--compoundName is used:
    * kgml2sif attempts to name gene nodes (-g/--geneSymbol) or compound nodes
      (-c/--compoundName) according to a provided conversion table "KEGG ID to
      KEGG name"
    * the conversion table must be a 2-columns TSV file (see the files
      "gene2symbol.tsv" and "compound2name.tsv" provided with kgml2sif)
    * unmatched KEGG IDs are left unchanged in the output SIF file and kgml2sif
      warns about it

Node name prefixes in KGML:
    * specify the node type
    * the name of nodes representing human genes is prefixed with "hsa:"
    * the name of nodes representing compounds is prefixed with "cpd:"
    * the name of nodes representing glycans (a subtype of compounds) is
      prefixed with "gl:"
    * the name of nodes representing drugs (a subtype of compounds) is prefixed
      with "dr:"

Full explanation of the KGML file format at https://www.kegg.jp/kegg/xml/docs/

For explanations about the SIF file format, see the readme file of kgml2sif.
""",
formatter_class=argparse.RawDescriptionHelpFormatter
)
parser.add_argument(
    "kgmlFile",
    type=str,
    metavar="<kgmlFile>",
    help="a KGML-encoded KEGG human pathway",
    nargs="+"
)
parser.add_argument(
    "-g",
    "--geneSymbol",
    type=str,
    metavar="<tsvFile>",
    help="a conversion table for translating KEGG human gene IDs to gene symbols (see the file \"gene2symbol.tsv\" provided with kgml2sif)"
)
parser.add_argument(
    "-c",
    "--compoundName",
    type=str,
    metavar="<tsvFile>",
    help="a conversion table for translating KEGG compound IDs to compound names (see the file \"compound2name.tsv\" provided with kgml2sif)"
)
args=parser.parse_args()
#### GLOBALS ###################################################################
gene2symbol={}
compound2name={}
nodeTypes=[
    "gene",
    "compound",
    "group"
]
relationTypes=[
    "PPrel",
    "GErel",
    "PCrel",
    "ECrel"
]
relationAdds=[
    "CPXrel"
]
nodePrefixes={
    "gene":["hsa:"],
    "compound":["cpd:C","gl:G","dr:D"]
}
#### GENE2SYMBOL ###############################################################
if args.geneSymbol!=None:
    warnFile=list(os.path.splitext(args.geneSymbol))
    warnFile[1]=".warns.kgml2sif.txt"
    warnFile="".join(warnFile)
    warns=[]
    for line in open(args.geneSymbol,"rt").read().splitlines():
        if line.count("\t")!=1:
            warns.append(line+": must be a 2 fields TSV, skipping")
        else:
            line=line.split("\t")
            ok=True
            for val in line:
                if val=="":
                    warns.append("\t".join(line)+": empty field(s), skipping")
                    ok=False
                    break
            if ok:
                if not (line[0].startswith("hsa:") and line[0].replace("hsa:","").isnumeric()):
                    warns.append("\t".join(line)+": invalid KEGG human gene ID, skipping")
                elif line[0] in gene2symbol.keys():
                    warns.append("\t".join(line)+": duplicated KEGG human gene ID, skipping")
                else:
                    gene2symbol[line[0]]=line[1]
    if len(warns)!=0:
        print("Warning: "+args.geneSymbol+": see "+warnFile)
        open(warnFile,"w").write("\n".join(warns)+"\n")
    if len(gene2symbol.keys())==0:
        print("Error: "+args.geneSymbol+": no valid gene2symbol found, quitting")
        quit()
#### COMPOUND2NAME #############################################################
if args.compoundName!=None:
    warnFile=list(os.path.splitext(args.compoundName))
    warnFile[1]=".warns.kgml2sif.txt"
    warnFile="".join(warnFile)
    warns=[]
    for line in open(args.compoundName,"rt").read().splitlines():
        if line.count("\t")!=1:
            warns.append(line+": must be a 2 fields TSV, skipping")
        else:
            line=line.split("\t")
            ok=True
            for val in line:
                if val=="":
                    warns.append("\t".join(line)+": empty field(s), skipping")
                    ok=False
                    break
            if ok:
                if not ((line[0].startswith("cpd:C") and line[0].replace("cpd:C","").lstrip("0").isnumeric()) or (line[0].startswith("gl:G") and line[0].replace("gl:G","").lstrip("0").isnumeric()) or (line[0].startswith("dr:D") and line[0].replace("dr:D","").lstrip("0").isnumeric())):
                    warns.append("\t".join(line)+": invalid KEGG compound ID, skipping")
                elif line[0] in compound2name.keys():
                    warns.append("\t".join(line)+": duplicated KEGG compound ID, skipping")
                else:
                    compound2name[line[0]]=line[1]
    if len(warns)!=0:
        print("Warning: "+args.compoundName+": see "+warnFile)
        open(warnFile,"w").write("\n".join(warns)+"\n")
    if len(compound2name.keys())==0:
        print("Error: "+args.compoundName+": no valid compound2name found, quitting")
        quit()
#### KGML FILES ################################################################
for kgmlFile in args.kgmlFile:
    #### OUT FILES #############################################################
    warnFile=list(os.path.splitext(kgmlFile))
    sifFile=list(os.path.splitext(kgmlFile))
    notFoundFile=list(os.path.splitext(kgmlFile))
    bothFile=list(os.path.splitext(kgmlFile))
    multiFile=list(os.path.splitext(kgmlFile))
    warnFile[1]=".warns.txt"
    sifFile[1]=".sif"
    notFoundFile[1]=".noNames.txt"
    bothFile[1]=".multiNames.txt"
    multiFile[1]=".multiEdges.sif"
    warnFile="".join(warnFile)
    sifFile="".join(sifFile)
    notFoundFile="".join(notFoundFile)
    bothFile="".join(bothFile)
    multiFile="".join(multiFile)
    #### LOCALS ################################################################
    warns=[]
    nodes={}
    complexes={}
    edges={}
    sif=[]
    notFound=[]
    both=[]
    multiEdges=[]
    root=xml.etree.ElementTree.parse(kgmlFile).getroot()
    #### NODES #################################################################
    for element in root.findall("entry"):
        type_=element.get("type")
        ID=element.get("id")
        name=element.get("name")
        if type_ in nodeTypes:
            if (ID==None) or (ID==""):
                warns.append(type_+": no ID, skipping")
            elif (ID in nodes.keys()) or (ID in complexes.keys()):
                warns.append(type_+": "+ID+": duplicated ID, skipping")
            elif (name==None) or (name==""):
                warns.append(type_+": "+ID+": no name(s), skipping")
            else:
                if type_=="group":
                    complexes[ID]=copy.deepcopy(element)
                else:
                    keggIDs=[]
                    ok=True
                    for keggID in name.split(" "):
                        prefix=None
                        for val in nodePrefixes[type_]:
                            if keggID.startswith(val):
                                prefix=val
                                break
                        if prefix==None:
                            warns.append(type_+": "+ID+": "+keggID+": invalid prefix, skipping")
                            ok=False
                            break
                        elif not keggID.replace(prefix,"").lstrip("0").isnumeric():
                            warns.append(type_+": "+ID+": "+keggID+": invalid syntax, skipping")
                            ok=False
                            break
                        else:
                            if keggID not in keggIDs:
                                keggIDs.append(keggID)
                    if ok:
                        if len(keggIDs)==0:
                            warns.append(type_+": "+ID+": "+name+": no valid name(s), skipping")
                        else:
                            nodes[ID]={
                                "type":type_,
                                "name":copy.deepcopy(keggIDs)
                            }
    if len(nodes.keys())==0:
        if len(warns)!=0:
            print("Warning: "+kgmlFile+": see "+warnFile)
            open(warnFile,"w").write("\n".join(warns)+"\n")
        print("Error: "+kgmlFile+": no valid nodes found, skipping")
        continue
    #### NAME NODES ############################################################
    if (args.geneSymbol!=None) or (args.compoundName!=None):
        for ID in nodes.keys():
            names=[]
            for keggID in nodes[ID]["name"]:
                name=[]
                if (args.geneSymbol!=None) and (keggID in gene2symbol.keys()):
                    name.append(gene2symbol[keggID])
                if (args.compoundName!=None) and (keggID in compound2name.keys()):
                    name.append(compound2name[keggID])
                if len(name)==0:
                    if keggID not in notFound:
                        notFound.append(keggID)
                elif len(name)!=1:
                    if keggID not in both:
                        both.append(keggID)
                else:
                    if name not in names:
                        names.append(name[0])
            if len(names)==0:
                warns.append(type_+": "+ID+": "+", ".join(sorted(nodes[ID]["name"]))+": no valid name(s) found, skipping")
            elif len(names)!=len(nodes[ID]["name"]):
                warns.append(type_+": "+ID+": "+", ".join(sorted(nodes[ID]["name"]))+": "+", ".join(sorted(names))+": missing valid name(s), skipping")
            else:
                nodes[ID]["name"]=copy.deepcopy(names)
    #### COMPLEXES #############################################################
    for ID in complexes.keys():
        components=complexes[ID].findall("component")
        if len(components)==0:
            warns.append("complex: "+ID+": no components, skipping")
        elif len(components)==1:
            warns.append("complex: "+ID+": only one component, skipping")
        else:
            componentIDs=[]
            ok=True
            for component in components:
                componentID=component.get("id")
                if (componentID==None) or (componentID==""):
                    warns.append("complex: "+ID+": component with no ID, skipping")
                    ok=False
                    break
                elif componentID not in nodes.keys():
                    warns.append("complex: "+ID+": "+componentID+": unknown or unconsidered component, skipping")
                    ok=False
                    break
                else:
                    if componentID not in componentIDs:
                        componentIDs.append(componentID)
            if ok:
                if len(componentIDs)==0:
                    warns.append("complex: "+ID+": no valid components, skipping")
                else:
                    components=[]
                    cpxs=[]
                    nodes[ID]={
                        "type":"complex",
                        "name":[]
                    }
                    for componentID in componentIDs:
                        components.append(copy.deepcopy(nodes[componentID]["name"]))
                    m=len(components)
                    n=1
                    for component in components:
                        n*=len(component)
                    for i in range(n):
                        cpx=[]
                        for j in range(m):
                            cpx.append(None)
                        cpxs.append(copy.deepcopy(cpx))
                    for j in range(m):
                        q=len(components[j])
                        p=1
                        for i in range(j+1,m):
                            p*=len(components[i])
                        for i in range(n):
                            cpxs[i][j]=components[j][(i//p)%q]
                    for cpx in cpxs:
                        name="&".join(sorted(cpx))
                        if name not in nodes[ID]["name"]:
                            nodes[ID]["name"].append(name)
                        for node in cpx:
                            sif.append([node,["membership_CPXrel"],name])
    #### RELATIONS #############################################################
    for relation in root.findall("relation"):
        type_=relation.get("type")
        entry1=relation.get("entry1")
        entry2=relation.get("entry2")
        subtypes=relation.findall("subtype")
        if type_ in relationTypes:
            if (entry1==None) or (entry1==""):
                warns.append(type_+": no source node, skipping")
            elif (entry2==None) or (entry2==""):
                warns.append(type_+": no target node, skipping")
            elif entry1 not in nodes.keys():
                warns.append(type_+": "+entry1+": unknown or unconsidered source node, skipping")
            elif entry2 not in nodes.keys():
                warns.append(type_+": "+entry2+": unknown or unconsidered target node, skipping")
            elif (type_=="PPrel") and not ((nodes[entry1]["type"] in ["gene","complex"]) and (nodes[entry2]["type"] in ["gene","complex"])):
                warns.append(type_+": ("+entry1+","+entry2+"): ("+nodes[entry1]["type"]+","+nodes[entry2]["type"]+"): invalid edge, skipping")
            elif (type_=="GErel") and not ((nodes[entry1]["type"] in ["gene","complex"]) and (nodes[entry2]["type"] in ["gene"])):
                warns.append(type_+": ("+entry1+","+entry2+"): ("+nodes[entry1]["type"]+","+nodes[entry2]["type"]+"): invalid edge, skipping")
            elif (type_=="PCrel") and not (((nodes[entry1]["type"] in ["gene","complex"]) and (nodes[entry2]["type"] in ["compound"])) or ((nodes[entry1]["type"] in ["compound"]) and (nodes[entry2]["type"] in ["gene","complex"]))):
                warns.append(type_+": ("+entry1+","+entry2+"): ("+nodes[entry1]["type"]+","+nodes[entry2]["type"]+"): invalid edge, skipping")
            elif (type_=="ECrel") and not ((nodes[entry1]["type"] in ["gene","complex"]) and (nodes[entry2]["type"] in ["gene","complex"])):
                warns.append(type_+": ("+entry1+","+entry2+"): ("+nodes[entry1]["type"]+","+nodes[entry2]["type"]+"): invalid edge, skipping")
            else:
                ok=True
                if len(subtypes)==0:
                    names=["unknown"]
                else:
                    names=[]
                    for subtype in subtypes:
                        name=subtype.get("name")
                        if (name==None) or (name==""):
                            warns.append(type_+": ("+entry1+","+entry2+"): empty name, skipping")
                            ok=False
                            break
                        else:
                            if name not in names:
                                names.append(name)
                if ok:
                    if len(names)==0:
                        warns.append(type_+": ("+entry1+","+entry2+"): no valid name(s), skipping")
                    else:
                        for i in range(len(names)):
                            names[i]="_".join([names[i],type_])
                        for source in nodes[entry1]["name"]:
                            for target in nodes[entry2]["name"]:
                                sif.append([source,copy.deepcopy(names),target])
    if len(sif)==0:
        if len(warns)!=0:
            print("Warning: "+kgmlFile+": see "+warnFile)
            open(warnFile,"w").write("\n".join(warns)+"\n")
        print("Error: "+kgmlFile+": no valid edges found, skipping")
        continue
    #### CLEAN #################################################################
    for line in sif:
        edges[line[0]]={}
    for line in sif:
        edges[line[0]][line[2]]={}
    for source in edges.keys():
        for target in edges[source].keys():
            for type_ in relationTypes+relationAdds:
                edges[source][target][type_]=[]
    for line in sif:
        for relation in line[1]:
            for type_ in relationTypes+relationAdds:
                if relation.endswith(type_):
                    if relation not in edges[line[0]][line[2]][type_]:
                        edges[line[0]][line[2]][type_].append(relation)
                    break
    sif=[]
    for source in edges.keys():
        for target in edges[source].keys():
            multi=0
            for type_ in edges[source][target].keys():
                if len(edges[source][target][type_])!=0:
                    multi+=1
            for type_ in edges[source][target].keys():
                if len(edges[source][target][type_])!=0:
                    edge="\t".join([source,",".join(sorted(edges[source][target][type_])),target])
                    if edge not in sif:
                        sif.append(edge)
                    if (multi>1) and (edge not in multiEdges):
                        multiEdges.append(edge)
    #### OUTPUTS ###############################################################
    if len(warns)!=0:
        print("Warning: "+kgmlFile+": see "+warnFile)
        open(warnFile,"w").write("\n".join(warns)+"\n")
    if len(notFound)!=0:
        print("Warning: "+sifFile+": contains unmatched node ID(s), see: "+notFoundFile)
        open(notFoundFile,"w").write("\n".join(sorted(notFound))+"\n")
    if len(both)!=0:
        print("Warning: "+sifFile+": contains multimatched node ID(s), see: "+bothFile)
        open(bothFile,"w").write("\n".join(sorted(both))+"\n")
    if len(multiEdges)!=0:
        print("Warning: "+sifFile+": contains multiedges, see "+multiFile)
        open(multiFile,"w").write("\n".join(sorted(multiEdges))+"\n")
    open(sifFile,"w").write("\n".join(sorted(sif))+"\n")
